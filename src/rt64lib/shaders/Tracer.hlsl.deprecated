//
// RT64
//

#include "Color.hlsli"
#include "Constants.hlsli"
#include "GlobalBuffers.hlsli"
#include "GlobalHitBuffers.hlsli"
#include "Materials.hlsli"
#include "Instances.hlsli"
#include "Ray.hlsli"
#include "Random.hlsli"
#include "Textures.hlsli"
#include "GlobalParams.hlsli"
#include "SkyPlaneUV.hlsli"
#include "Lights.hlsli"

#define FULL_QUALITY_ALPHA					0.999f
#define GI_MINIMUM_ALPHA					0.25f

#define DEBUG_HIT_COUNT						0

SamplerState gBackgroundSampler : register(s0);

float3 ComputeLightsOrdered(float3 rayDirection, uint instanceId, float3 position, float3 normal, float3 specular, uint maxLights, const bool checkShadows, uint seed) {
	float3 resultLight = float3(0.0f, 0.0f, 0.0f);
	uint lightGroupMaskBits = instanceMaterials[instanceId].lightGroupMaskBits;
	float ignoreNormalFactor = instanceMaterials[instanceId].ignoreNormalFactor;
	if (lightGroupMaskBits > 0) {
		// Build an array of the n closest lights by measuring their intensity.
		uint sMaxLightCount = min(maxLights, MAX_LIGHTS);
		float sLightIntensityFactors[MAX_LIGHTS + 1];
		uint sLightIndices[MAX_LIGHTS + 1];
		uint sLightCount = 0;
		uint gLightCount, gLightStride;
		SceneLights.GetDimensions(gLightCount, gLightStride);
		for (uint l = 0; l < gLightCount; l++) {
			if (lightGroupMaskBits & SceneLights[l].groupBits) {
				float lightIntensityFactor = CalculateLightIntensitySimple(l, position, normal, ignoreNormalFactor);
				if (lightIntensityFactor > EPSILON) {
					uint hi = min(sLightCount, sMaxLightCount);
					uint lo = hi - 1;
					while ((hi > 0) && (lightIntensityFactor > sLightIntensityFactors[lo])) {
						sLightIntensityFactors[hi] = sLightIntensityFactors[lo];
						sLightIndices[hi] = sLightIndices[lo];
						hi--;
						lo--;
					}

					sLightIntensityFactors[hi] = lightIntensityFactor;
					sLightIndices[hi] = l;
					sLightCount++;
				}
			}
		}

		float3 lightingFactors;
		sLightCount = min(sLightCount, sMaxLightCount);
		for (uint s = 0; s < sLightCount; s++) {
			resultLight += ComputeLight(sLightIndices[s], rayDirection, instanceId, position, normal, specular, checkShadows, seed + s);
		}
	}

	return resultLight;
}

float4 ComputeFog(uint instanceId, float3 position) {
	float4 fogColor = float4(instanceMaterials[instanceId].fogColor, 0.0f);
	float fogMul = instanceMaterials[instanceId].fogMul;
	float fogOffset = instanceMaterials[instanceId].fogOffset;
	float4 clipPos = mul(mul(projection, view), float4(position.xyz, 1.0f));

	// Values from the game are designed around -1 to 1 space.
	clipPos.z = clipPos.z * 2.0f - clipPos.w;

	float winv = 1.0f / max(clipPos.w, 0.001f);
	const float DivisionFactor = 255.0f;
	fogColor.a = min(max((clipPos.z * winv * fogMul + fogOffset) / DivisionFactor, 0.0f), 1.0f);
	return fogColor;
}

float2 FakeEnvMapUV(float3 rayDirection, float yawOffset) {
	float yaw = fmod(yawOffset + atan2(rayDirection.x, -rayDirection.z) + M_PI, M_TWO_PI);
	float pitch = fmod(atan2(-rayDirection.y, sqrt(rayDirection.x * rayDirection.x + rayDirection.z * rayDirection.z)) + M_PI, M_TWO_PI);
	return float2(yaw / M_TWO_PI, pitch / M_TWO_PI);
}

float3 SampleBackground2D(float2 screenUV) {
	return gBackground.SampleLevel(gBackgroundSampler, screenUV, 0).rgb;
}

float3 SampleBackgroundAsEnvMap(float3 rayDirection) {
	return gBackground.SampleLevel(gBackgroundSampler, FakeEnvMapUV(rayDirection, 0.0f), 0).rgb;
}

float4 SampleSky2D(float2 screenUV) {
	if (skyPlaneTexIndex >= 0) {
		float2 skyUV = ComputeSkyPlaneUV(screenUV, viewI, viewport.zw, skyYawOffset);
		float4 skyColor = gTextures[skyPlaneTexIndex].SampleLevel(gBackgroundSampler, skyUV, 0);
		skyColor.rgb *= skyDiffuseMultiplier.rgb;

		if (any(skyHSLModifier)) {
			skyColor.rgb = ModRGBWithHSL(skyColor.rgb, skyHSLModifier.rgb);
		}

		return skyColor;
	}
	else {
		return float4(0.0f, 0.0f, 0.0f, 0.0f);
	}
}

float4 SampleSkyPlane(float3 rayDirection) {
	if (skyPlaneTexIndex >= 0) {
		float4 skyColor = gTextures[skyPlaneTexIndex].SampleLevel(gBackgroundSampler, FakeEnvMapUV(rayDirection, skyYawOffset), 0);
		skyColor.rgb *= skyDiffuseMultiplier.rgb;

		if (any(skyHSLModifier)) {
			skyColor.rgb = ModRGBWithHSL(skyColor.rgb, skyHSLModifier.rgb);
		}

		return skyColor;
	}
	else {
		return float4(0.0f, 0.0f, 0.0f, 0.0f);
	}
}

float3 SimpleShadeFromGBuffers(uint hitOffset, uint hitCount, float3 rayOrigin, float3 rayDirection, uint2 launchIndex, uint2 pixelDims, const bool checkShadows, const bool giBounce, uint seed) {
	// Mix background and sky color together.
	float3 bgColor = SampleBackgroundAsEnvMap(rayDirection);
	float4 skyColor = SampleSkyPlane(rayDirection);
	bgColor = lerp(bgColor, skyColor.rgb, skyColor.a);

	// Process hits.
	float4 resColor = float4(0, 0, 0, 1);
	float3 simpleLightsResult = float3(0.0f, 0.0f, 0.0f);
	uint maxSimpleLights = 1;
	for (uint hit = hitOffset; hit < hitCount; hit++) {
		uint hitBufferIndex = getHitBufferIndex(hit, launchIndex, pixelDims);
		float4 hitColor = gHitColor[hitBufferIndex];
		float alphaContrib = (resColor.a * hitColor.a);
		if (alphaContrib >= EPSILON) {
			uint instanceId = gHitInstanceId[hitBufferIndex];
			uint lightGroupMaskBits = instanceMaterials[instanceId].lightGroupMaskBits;
			float3 vertexPosition = rayOrigin + rayDirection * WithoutDistanceBias(gHitDistAndFlow[hitBufferIndex].x, instanceId);
			float3 vertexNormal = gHitNormal[hitBufferIndex].xyz;
			float3 vertexSpecular = gHitSpecular[hitBufferIndex].rgb;
			float3 specular = instanceMaterials[instanceId].specularColor * vertexSpecular.rgb;
			float3 resultLight = instanceMaterials[instanceId].selfLight;
			float3 resultGiLight = ambientNoGIColor.rgb;

			// Reuse the previous computed lights result if available.
			if (lightGroupMaskBits > 0) {
				if (maxSimpleLights > 0) {
					simpleLightsResult = ComputeLightsOrdered(rayDirection, instanceId, vertexPosition, vertexNormal, specular, 1, checkShadows, seed + hit);
					maxSimpleLights--;
				}

				resultLight += simpleLightsResult;
			}

			resultLight += ambientBaseColor.rgb + resultGiLight;
			hitColor.rgb *= resultLight;

			// Backwards alpha blending.
			resColor.rgb += hitColor.rgb * alphaContrib;
			resColor.a *= (1.0 - hitColor.a);
		}

		if (resColor.a <= EPSILON) {
			break;
		}
	}

	float bgMult = giBounce ? giSkyStrength : 1.0f;
	float resMult = giBounce ? giDiffuseStrength : 1.0f;
	return lerp(bgColor.rgb * bgMult, resColor.rgb * resMult, (1.0 - resColor.a));
}

uint TraceSurface(float3 rayOrigin, float3 rayDirection, float rayMinDist, float rayMaxDist, uint rayHitOffset) {
	// Fill ray.
	RayDesc ray;
	ray.Origin = rayOrigin;
	ray.Direction = rayDirection;
	ray.TMin = rayMinDist;
	ray.TMax = rayMaxDist;

	// Fill payload.
	HitInfo payload;
	payload.nhits = rayHitOffset;
	payload.ohits = rayHitOffset;

	// Make call.
	TraceRay(SceneBVH, RAY_FLAG_FORCE_NON_OPAQUE | RAY_FLAG_CULL_BACK_FACING_TRIANGLES | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, 0xFF, 0, 0, 0, ray, payload);
	return payload.nhits;
}

float3 TraceSimple(float3 rayOrigin, float3 rayDirection, float rayMinDist, float rayMaxDist, uint hitOffset, uint2 launchIndex, uint2 pixelDims, const bool checkShadows, const bool giBounce, uint seed) {
	uint hitCount = TraceSurface(rayOrigin, rayDirection, rayMinDist, rayMaxDist, hitOffset);
	return SimpleShadeFromGBuffers(hitOffset, min(hitCount, MAX_HIT_QUERIES), rayOrigin, rayDirection, launchIndex, pixelDims, checkShadows, giBounce, seed);
}

float FresnelReflectAmount(float3 normal, float3 incident, float reflectivity, float fresnelMultiplier) {
	// TODO: Probably use a more accurate approximation than this.
	float ret = pow(clamp(1.0f + dot(normal, incident), EPSILON, 1.0f), 5.0f);
	return reflectivity + ((1.0 - reflectivity) * ret * fresnelMultiplier);
}

float4 ComputeReflection(float reflectionFactor, float reflectionShineFactor, float reflectionFresnelFactor, float3 rayDirection, float3 position, float3 normal, uint hitOffset, uint2 launchIndex, uint2 pixelDims, uint seed) {
	float3 reflectionDirection = reflect(rayDirection, normal);
	float4 reflectionColor = float4(TraceSimple(position, reflectionDirection, RAY_MIN_DISTANCE, RAY_MAX_DISTANCE, hitOffset, launchIndex, pixelDims, false, false, seed), 0.0f);
	const float3 HighlightColor = float3(1.0f, 1.05f, 1.2f);
	const float3 ShadowColor = float3(0.1f, 0.05f, 0.0f);
	const float BlendingExponent = 3.0f;
	reflectionColor.rgb = lerp(reflectionColor.rgb, HighlightColor, pow(max(reflectionDirection.y, 0.0f) * reflectionShineFactor, BlendingExponent));
	reflectionColor.rgb = lerp(reflectionColor.rgb, ShadowColor, pow(max(-reflectionDirection.y, 0.0f) * reflectionShineFactor, BlendingExponent));
	reflectionColor.a = FresnelReflectAmount(normal, rayDirection, reflectionFactor, reflectionFresnelFactor);
	return reflectionColor;
}

float2 WorldToScreenPos(float4x4 viewProj, float3 worldPos) {
	float4 clipSpace = mul(viewProj, float4(worldPos, 1.0f));
	float3 NDC = clipSpace.xyz / clipSpace.w;
	return (0.5f + NDC.xy / 2.0f);
}

void FullShadeFromGBuffers(uint hitCount, float3 rayOrigin, float3 rayDirection, uint2 launchIndex, uint2 pixelDims, uint seed) {
	float2 screenUV = float2(launchIndex.x, launchIndex.y) / float2(pixelDims.x, pixelDims.y);
	float3 bgColor = SampleBackground2D(screenUV);
	float4 skyColor = SampleSky2D(screenUV);
	bgColor = lerp(bgColor, skyColor.rgb, skyColor.a);
	
	float3 bgPosition = rayOrigin + rayDirection * RAY_MAX_DISTANCE;
	float2 prevBgPos = WorldToScreenPos(prevViewProj, bgPosition);
	float2 curBgPos = WorldToScreenPos(viewProj, bgPosition);
	float4 resColor = float4(0.0f, 0.0f, 0.0f, 1.0f);
	float4 finalAlbedo = float4(bgColor, 1.0f);
	float4 finalNormal = float4(-rayDirection, 0.0f);
	float4 finalFlow = float4((curBgPos - prevBgPos) * resolution.xy, 0.0f, 0.0f);
	float3 simpleLightsResult = float3(0.0f, 0.0f, 0.0f);
	uint maxRefractions = 1;
	uint maxSimpleLights = 1;
	uint maxFullLights = 1;
	uint maxGI = 1;
	uint maxSimpleLightSamples = min(maxLightSamples, 2);
	for (uint hit = 0; hit < hitCount; hit++) {
		uint hitBufferIndex = getHitBufferIndex(hit, launchIndex, pixelDims);
		uint instanceId = gHitInstanceId[hitBufferIndex];
		float hitDistance = WithoutDistanceBias(gHitDistAndFlow[hitBufferIndex].x, instanceId);
		seed += asuint(hitDistance);

		float4 hitColor = gHitColor[hitBufferIndex];
		float3 vertexPosition = rayOrigin + rayDirection * hitDistance;
		float3 vertexNormal = gHitNormal[hitBufferIndex].xyz;
		float refractionFactor = instanceMaterials[instanceId].refractionFactor;
		float alphaContrib = (resColor.a * hitColor.a);
		if (alphaContrib >= EPSILON) {
			// Calculate motion vector in screen space.
			float3 vertexFlow = gHitDistAndFlow[hitBufferIndex].yzw;
			float2 prevPos = WorldToScreenPos(prevViewProj, vertexPosition - vertexFlow);
			float2 curPos = WorldToScreenPos(viewProj, vertexPosition);
			float2 resultFlow = curPos - prevPos;
			
			// Store values for global buffers.
			bool solidColor = (hitColor.a >= FULL_QUALITY_ALPHA);
			bool lastHit = (((hit + 1) >= hitCount) && (refractionFactor <= EPSILON));
			if (solidColor || lastHit) {
				finalAlbedo = float4(lerp(bgColor, hitColor.rgb, hitColor.a), 1.0f);
				finalNormal = float4(vertexNormal, 0.0f);
				finalFlow = float4(resultFlow * resolution.xy, 0.0f, 0.0f);
			}

			// Lighting.
			uint lightGroupMaskBits = instanceMaterials[instanceId].lightGroupMaskBits;
			float3 resultLight = instanceMaterials[instanceId].selfLight;
			float3 resultGiLight = ambientNoGIColor.rgb;
			if (lightGroupMaskBits > 0) {
				float3 vertexSpecular = gHitSpecular[hitBufferIndex].rgb;
				float3 specular = instanceMaterials[instanceId].specularColor * vertexSpecular;

				// Full light sampling.
				if ((maxFullLights > 0) && (solidColor || lastHit)) {
					resultLight += ComputeLightsRandom(rayDirection, instanceId, vertexPosition, vertexNormal, specular, maxLightSamples, true, seed);
					maxFullLights--;
				}
				// Simple light sampling. Reuse previous result if calculated once already.
				else {
					if (maxSimpleLights > 0) {
						simpleLightsResult += ComputeLightsRandom(rayDirection, instanceId, vertexPosition, vertexNormal, specular, maxSimpleLightSamples, true, seed);
						maxSimpleLights--;
					}

					resultLight += simpleLightsResult;
				}

				// Global illumination.
				bool alphaGIRequired = (alphaContrib >= GI_MINIMUM_ALPHA);
				if ((giBounces > 0) && (maxGI > 0) && (alphaGIRequired || lastHit)) {
					uint giSamples = giBounces;
					uint seedCopy = seed;
					resultGiLight = float3(0.0f, 0.0f, 0.0f);
					while (giSamples > 0) {
						float3 bounceDir = getCosHemisphereSample(seedCopy, vertexNormal);
						float3 bounceColor = TraceSimple(vertexPosition, bounceDir, RAY_MIN_DISTANCE, RAY_MAX_DISTANCE, hitCount, launchIndex, pixelDims, true, true, seed + giSamples);
						resultGiLight += bounceColor / giBounces;
						giSamples--;
					}

					maxGI--;
				}

				// Eye light.
				float specularExponent = instanceMaterials[instanceId].specularExponent;
				float eyeLightLambertFactor = max(dot(vertexNormal, -rayDirection), 0.0f);
				float3 eyeLightReflected = reflect(rayDirection, vertexNormal);
				float3 eyeLightSpecularFactor = specular * pow(max(saturate(dot(eyeLightReflected, -rayDirection)), 0.0f), specularExponent);
				resultLight += (eyeLightDiffuseColor.rgb * eyeLightLambertFactor + eyeLightSpecularColor.rgb * eyeLightSpecularFactor);
			}
			
			// Apply lighting.
			resultLight += ambientBaseColor.rgb + resultGiLight;
			hitColor.rgb *= resultLight;

			// Add reflections.
			float reflectionFactor = instanceMaterials[instanceId].reflectionFactor;
			if (reflectionFactor > EPSILON) {
				float reflectionFresnelFactor = instanceMaterials[instanceId].reflectionFresnelFactor;
				float reflectionShineFactor = instanceMaterials[instanceId].reflectionShineFactor;
				float4 reflectionColor = ComputeReflection(reflectionFactor, reflectionShineFactor, reflectionFresnelFactor, rayDirection, vertexPosition, vertexNormal, hitCount, launchIndex, pixelDims, seed);
				hitColor.rgb = lerp(hitColor.rgb, reflectionColor.rgb, reflectionColor.a);
			}

			// Calculate the fog for the resulting color using the camera data if the option is enabled.
			if (instanceMaterials[instanceId].fogEnabled) {
				float4 fogColor = ComputeFog(instanceId, vertexPosition);
				hitColor.rgb = lerp(hitColor.rgb, fogColor.rgb, fogColor.a);
			}

			// Special visualization modes for debugging.
			if (visualizationMode == VISUALIZATION_MODE_LIGHTS) {
				hitColor.rgb = resultLight;
			}

			// Backwards alpha blending.
			resColor.rgb += hitColor.rgb * alphaContrib;
			resColor.a *= (1.0f - hitColor.a);
		}

		if (resColor.a <= EPSILON) {
			break;
		}

		// Do refractions.
		if ((refractionFactor > EPSILON) && (maxRefractions > 0)) {
			float3 refractionDirection = refract(rayDirection, vertexNormal, refractionFactor);

			// Perform another trace and fill the rest of the buffers.
			hitCount = TraceSurface(vertexPosition, refractionDirection, RAY_MIN_DISTANCE, RAY_MAX_DISTANCE, hit + 1);
			rayOrigin = vertexPosition;
			rayDirection = refractionDirection;
			maxRefractions--;
		}
	}

	// Blend with the background.
	resColor.rgb += bgColor * resColor.a;

	if (visualizationMode != VISUALIZATION_MODE_NORMAL) {
		finalAlbedo = float4(1.0f, 1.0f, 1.0f, 1.0f);
	}

	gOutput[launchIndex] = float4(resColor.rgb, 1.0f);
	gAlbedo[launchIndex] = finalAlbedo;
	gNormal[launchIndex] = finalNormal;
	gFlow[launchIndex] = finalFlow;

#if DEBUG_HIT_COUNT == 1
	float4 colors[MAX_HIT_QUERIES + 1] =
	{
		float4(0.00, 0.00, 0.00, 1.00),
		float4(0.33, 0.00, 0.00, 1.00),
		float4(0.66, 0.00, 0.00, 1.00),
		float4(1.00, 0.00, 0.00, 1.00),
		float4(0.00, 0.33, 0.00, 1.00),
		float4(0.00, 0.66, 0.00, 1.00),
		float4(0.00, 1.00, 0.00, 1.00),
		float4(0.00, 0.00, 0.33, 1.00),
		float4(0.00, 0.00, 0.66, 1.00),
		float4(0.00, 0.00, 1.00, 1.00),
		float4(0.33, 0.33, 0.00, 1.00),
		float4(0.66, 0.66, 0.00, 1.00),
		float4(1.00, 1.00, 0.00, 1.00),
		float4(0.00, 0.33, 0.33, 1.00),
		float4(0.00, 0.66, 0.66, 1.00),
		float4(0.00, 1.00, 1.00, 1.00),
		float4(1.00, 1.00, 1.00, 1.00),
	};

	gOutput[launchIndex] = colors[hitCount];
#endif
}

void TraceFull(float3 rayOrigin, float3 rayDirection, float rayMinDist, float rayMaxDist, uint2 launchIndex, uint2 pixelDims, uint seed) {
	uint hitCount = TraceSurface(rayOrigin, rayDirection, rayMinDist, rayMaxDist, 0);
	FullShadeFromGBuffers(min(hitCount, MAX_HIT_QUERIES), rayOrigin, rayDirection, launchIndex, pixelDims, seed);
}

[shader("raygeneration")]
void TraceRayGen() {
	uint2 launchIndex = DispatchRaysIndex().xy;
	uint2 launchDims = DispatchRaysDimensions().xy;
	float2 d = (((launchIndex.xy + 0.5f) / float2(launchDims)) * 2.f - 1.f);
	float3 rayOrigin = mul(viewI, float4(0, 0, 0, 1)).xyz;
	float4 target = mul(projectionI, float4(d.x, -d.y, 1, 1));
	float3 rayDirection = mul(viewI, float4(target.xyz, 0)).xyz;
	uint seed = initRand(launchIndex.x + launchIndex.y * launchDims.x, randomSeed, 16);
	TraceFull(rayOrigin, rayDirection, RAY_MIN_DISTANCE, RAY_MAX_DISTANCE, launchIndex, launchDims, seed);
}

[shader("miss")]
void SurfaceMiss(inout HitInfo payload : SV_RayPayload) {
	// No-op.
}

[shader("miss")]
void ShadowMiss(inout ShadowHitInfo payload : SV_RayPayload) {
	// No-op.
}